### 0x01 解析

​	很容易就可以看出题目是一个若依系统，直接上网搜索就可以知道ry有一个人尽皆知的漏洞，任意文件读取。但这是一个后台漏洞，也就是说我们在使用这个漏洞之前，需要进入后台或者未授权调用文件读取接口。

​	信息搜集可以发现，该框架使用的是`shiro`，那就要考虑是否含有未授权绕过，直接尝试如下payload:

```java
js/../common/download?fileName=../../../../../../etc/passwd
```

​	可以发现确实含有任意文件读取漏洞，但在尝试读取flag的时候会发现，因为不知道flag的文件名而无法读取。这时候想到这是一个`shiro`，那么应该存在shiro反序列化漏洞，那读取shiro的key就是我们目前的目的了。

​	shiro的key一般在配置文件中，通过网上下载的ry源码也可以轻松看出。但另一个问题就是我们根本无法知道配置文件的路径。但通过读取到了`/etc/passwd`，我们可以知道这是linux系统，那么直接尝试读取`/proc/self/fd/4`可能就是最优解。

PS: linux文件系统下的`proc`含有所有系统的进程信息，这里的`/proc/self`文件夹下面就是我们ry web服务这个进程的所有信息，`fd`目录就是进程的文件信息，那么源码很可能就在`/proc/self/fd`文件夹下，至于文件名为什么是4，是因为启动服务使用的是`java -jar xxx.jar`这种方式，就是不知道是源码的文件名是4，也可以直接`1-100`遍历。

所以，最终读取源码的payload如下:

```java
js/../common/download?fileName=../../../../../../proc/self/fd/4
```

然后将读取到的文件后缀名改为`.zip`直接解压。成功找到`key`。

![image-20210607202913617](https://i.loli.net/2021/06/07/UMrxau7dTV2nqID.png)

有了key之后直接使用工具就可以getshell。

环境关了，不再演示。。